# 2026-02-07

## 00:20 — Request Timeout + Type Safety Cleanup (PLANNING.md items 3 & 4c)

### Core Decision/Topic

Implemented two features from the improvement roadmap: **Request Timeout** (item 3) and **Proxy Type Safety — any-to-unknown cleanup** (item 4c). These were chosen as the two simplest, standalone tasks to tackle first.

### Options Considered

**Request Timeout:**
- Per-call timeout (e.g. `api.slowOp.$timeout(60_000).call(...)`) vs global channel timeout — chose **global timeout** as the simpler first step. Per-call can be added later.
- Timer storage: `Map` vs plain `Record` — used `Record` to match existing `pendingRequests` pattern.

**Type Safety (4c):**
- Full `any` → `unknown` conversion vs targeted cleanup — chose **targeted**. Many `any` usages are intentional escape hatches for dynamic RPC wire data:
  - `PendingRequest.resolve: (result: any)` — changing to `unknown` causes cascading type errors due to Promise contravariance. The `callMethod` return type would need to become `Promise<unknown>`, breaking the public API.
  - `args: any[]` in `callMethod` — changing breaks `callbackCache.get(arg)` since `Map<CallbackFunction, string>.get()` expects `CallbackFunction`, not `unknown`.
  - `let target: any` in object traversal — needed for dynamic property access on arbitrary API shapes.
- Decided to only change what's **safe and non-breaking**: `CallbackFunction` params, catch blocks, and the `isDestroyed` cast.

### Final Decision & Rationale

**Timeout:** Simple timer-per-pending-request pattern. `startTimeout()`/`clearTimeout()` helpers centralize the logic. `destroy()` now rejects all pending requests (previously they'd hang forever if the channel was torn down). `RPCTimeoutError` follows the same pattern as `RPCValidationError` — custom properties survive `serializeError` round-trip, type guard uses `.name` (not `instanceof`) for wire compatibility.

**Type Safety:** Changed 3 categories:
1. `CallbackFunction(...args: unknown[])` — args come from the wire, are truly unknown at runtime
2. `catch (error: unknown)` with `error instanceof Error ? error : new Error(String(error))` — forces proper narrowing instead of silently passing `any` to `sendError`
3. `(this.io as Record<string, unknown>).isDestroyed` — more precise than `as any`

### Key Changes Made

| File | Change |
|---|---|
| `packages/kkrpc/src/channel.ts` | Added `RPCTimeoutError`, `isRPCTimeoutError()`, `timeout` option, `pendingTimers` map, `startTimeout()`/`clearTimeout()` helpers, timer in all 4 call methods, timer clearing in `handleResponse()`, pending-reject in `destroy()`. Changed `CallbackFunction` to `unknown[]`, 5 catch blocks to `error: unknown`, `isDestroyed` cast. |
| `packages/kkrpc/__tests__/timeout.test.ts` | 8 new tests: unit tests for RPCTimeoutError + integration over WebSocket (fast pass, slow timeout, nested timeout, no-timeout default, destroy-rejects-pending) |
| `PLANNING.md` | Marked items 3 and 4c as done |

### Future Considerations

- **Per-call timeout** — could add `$timeout()` modifier on the proxy, or accept timeout in a call options object
- **Task 4a (recursive path types)** — would make `callMethod("math.grade1.add", [1, 2])` fully type-checked internally, but complex TS gymnastics risk confusing error messages. Deferred.
- **Remaining roadmap:** Middleware/Interceptors (item 1), Streaming/Subscriptions (item 2) still pending

## 00:23 — Move adapter dependencies to optional peerDependencies

### Core Decision/Topic

Slimmed down `kkrpc`'s install footprint by moving all adapter-specific packages out of `dependencies` and into `peerDependencies` with `optional: true`.

### Options Considered

- **Status quo** — keep everything in `dependencies`. Simple, but forces every consumer (including Electron/browser apps) to install `kafkajs`, `ioredis`, `amqplib`, `socket.io`, `@nats-io/transport-node`, `@tauri-apps/plugin-shell`, and `ws` even when unused.
- **Move to `optionalDependencies`** — npm would still attempt to install them and only silently skip on failure. Doesn't solve the problem cleanly.
- **Move to `peerDependencies` + `peerDependenciesMeta.optional: true`** — consumers only install what they import. Package managers emit no warnings for missing optional peers. Chosen approach.

### Final Decision & Rationale

Only `superjson` remains in `dependencies` — it's used by the core serialization layer in every code path. Everything else is adapter-specific:

| Moved to optional peer | Adapter |
|---|---|
| `ws` | Node.js WebSocket (`kkrpc` main entry) |
| `socket.io` / `socket.io-client` | Socket.IO (`kkrpc/socketio`) |
| `ioredis` | Redis Streams (`kkrpc/redis-streams`) |
| `kafkajs` | Kafka (`kkrpc/kafka`) |
| `amqplib` | RabbitMQ (`kkrpc/rabbitmq`) |
| `@nats-io/transport-node` | NATS (`kkrpc/nats`) |
| `@tauri-apps/plugin-shell` | Tauri (`kkrpc` Tauri adapter) |

Also fixed a pre-existing inconsistency: `ioredis`, `kafkajs`, `socket.io`, and `socket.io-client` were listed in **both** `dependencies` and `peerDependencies`. The `dependencies` entry always wins, so the optional peer marking was effectively ignored.

### Key Changes Made

| File | Change |
|---|---|
| `packages/kkrpc/package.json` | Removed 8 packages from `dependencies` (keeping only `superjson`). Added `ws`, `@nats-io/transport-node`, `@tauri-apps/plugin-shell`, `amqplib` to `peerDependencies`. Added corresponding `optional: true` entries in `peerDependenciesMeta`. |

### Future Considerations

- **`pnpm-lock.yaml`** — will need `pnpm install` to reconcile the lockfile after this change
- **CI** — adapter tests that import these packages will need them installed explicitly in the test environment (likely already the case via devDependencies or workspace config)
- **Docs** — README adapter sections should note the required peer install (e.g., `npm install kkrpc kafkajs`)

## 01:05 — AsyncIterable Streaming Support (PLANNING.md item 2)

### Core Decision/Topic

Implemented **streaming / subscription support** — the final major feature from the roadmap. Server methods can now return `AsyncIterable` (async generators), and kkrpc automatically streams chunks to the client where they're consumed via `for await...of`.

### Options Considered

- **Dedicated subscription API** (e.g. `channel.subscribe("topic")`) vs **transparent AsyncIterable detection** — chose transparent detection. If a handler returns something with `Symbol.asyncIterator`, kkrpc streams it automatically. No new API surface for users to learn; async generators "just work".
- **Backpressure protocol** (consumer ACKs each chunk before producer sends next) vs **fire-and-forget chunks with buffering** — chose buffering. Simpler protocol, and most RPC streaming use cases (progress updates, log tailing, countdowns) don't need backpressure. Can be added later if needed.
- **Per-chunk interceptor calls** vs **interceptors wrap initial handler only** — chose handler-only. Interceptors see the method call that starts the stream but don't fire per-chunk. This matches how middleware works in gRPC and tRPC.

### Final Decision & Rationale

**Protocol:** 4 new message types added to the wire format:
- `stream-chunk` — producer → consumer, carries one value
- `stream-end` — producer → consumer, signals completion
- `stream-error` — producer → consumer, carries serialized error
- `stream-cancel` — consumer → producer, signals `break` in `for await`

The initial response carries `{ __stream: true }` to signal the consumer to create an AsyncIterable instead of resolving the Promise directly.

**Consumer-side queue pattern:** Chunks arrive asynchronously; consumer reads synchronously via `next()`. Bridged with a buffer + waiters queue — chunks that arrive before `next()` are buffered; `next()` calls that arrive before a chunk park as pending resolvers.

**Cancellation:** `break` in `for await` triggers the iterator's `return()` method, which sends `stream-cancel`. Producer uses `AbortController` to stop its iteration loop.

**Validation integration:** Per-chunk output validation supported — if a schema is configured for the method's output, each chunk is validated before sending.

### Key Changes Made

| File | Change |
|---|---|
| `packages/kkrpc/src/serialization.ts` | Extended `Message.type` union with 4 streaming message types |
| `packages/kkrpc/src/channel.ts` | Added ~200 lines: `StreamConsumerState`/`StreamProducerState` interfaces, `isAsyncIterable()` helper, stream routing in `processDecodedMessage`, producer methods (`streamResult`, `sendStreamError`, `handleStreamCancel`), consumer methods (`createStreamIterable`, `handleStreamChunk`, `handleStreamEnd`, `handleStreamError`), cleanup in `destroy()` |
| `packages/kkrpc/__tests__/streaming.test.ts` | 9 integration tests over real WebSocket: basic countdown, coexistence with regular methods, error propagation, consumer cancellation, concurrent streams, interceptor interaction, delayed chunks, empty stream, nested method streaming |
| `packages/kkrpc/README.md` | Added streaming section with code examples and comparison table row |
| `docs/src/content/docs/guides/streaming.md` | Standalone docs page covering usage, cancellation, errors, concurrency, protocol details |
| `examples/streaming-demo/` | Full working example: `api.ts` (3 streaming methods + 1 regular), `server.ts` (WebSocket + logging interceptor), `client.ts` (5 demo patterns), `README.md` |
| `PLANNING.md` | Removed — all planned features now implemented |

### Future Considerations

- **Backpressure** — for high-throughput streaming (e.g. file transfer), a flow-control protocol (consumer ACKs) would prevent memory buildup
- **Bidirectional streaming** — current design is server→client only. Client→server streaming would need a `sendStream()` API on the proxy
- **Stream timeout** — currently streams can run indefinitely. A per-stream idle timeout could auto-cancel stalled streams
- **PLANNING.md removed** — all 4 major roadmap items (middleware, streaming, timeout, type safety) are complete

## 01:47 — WebSocketLike interface + Bun native WebSocket support

### Core Decision/Topic

Fixed a type issue where `WebSocketServerIO` required a DOM `WebSocket` but the `ws` library's `WebSocket` type didn't fully match (missing `dispatchEvent`, `URL`). Added a structural `WebSocketLike` interface and created a Bun-native WebSocket server example.

### Options Considered

- **Cast in user code** (`ws as unknown as WebSocket`) — works but ugly, leaks implementation detail to users
- **Structural interface** (`WebSocketLike`) — defines only the members actually used (`onmessage`, `onerror`, `send`, `close`). Works with DOM WebSocket, `ws` library, and Bun's `ServerWebSocket` via a thin wrapper. Chosen approach.

### Final Decision & Rationale

**Structural typing over nominal:** The adapter only needs 4 operations. By defining `WebSocketLike` with those exact members, we accept anything that quacks like a WebSocket — no casts needed.

**Bun's callback-based API:** Bun uses `websocket: { message(ws, msg) }` callbacks rather than event setters. We bridge this with a wrapper stored in a `Map<ServerWebSocket, WebSocketLike>` — Bun's callbacks route to our wrapper's `onmessage` handler.

### Key Changes Made

| File | Change |
|---|---|
| `packages/kkrpc/src/adapters/websocket.ts` | Added exported `WebSocketLike` interface; changed `WebSocketServerIO` constructor to accept `WebSocketLike` instead of DOM `WebSocket` |
| `examples/streaming-middleware-demo/server.ts` | Removed cast; now passes `ws` directly |
| `examples/streaming-middleware-demo/server-bun.ts` | New file — Bun native WebSocket server using `Bun.serve()` with WebSocket upgrade |
| `examples/streaming-middleware-demo/package.json` | Added `server:bun` script; added `typescript` devDependency |
| `examples/streaming-middleware-demo/tsconfig.json` | New file — strict TypeScript config with `noUncheckedIndexedAccess` |

### Future Considerations

- **First-party Bun adapter** — could add `BunWebSocketIO` to kkrpc core that wraps Bun's native API directly, avoiding the user-space wrapper
- **Deno WebSocket** — similar pattern could work for Deno's native WebSocket server
- **WebSocketLike in client** — currently only server uses this; client still creates `new WebSocket()`. Could extend pattern if needed for non-DOM environments
