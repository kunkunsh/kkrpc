# Journal Entry - 2026-02-05

## 11:25 - Fixed Python RPC Server Callback Closure Bug

**Core Decision/Topic**: Fixed a critical Python closure bug in the kkrpc Python interop server that caused multiple callbacks in a single RPC request to all route to the same callback ID.

**Problem Analysis**:
The `_wrap_callbacks` method in `interop/python/kkrpc/server.py` creates callback wrapper functions inside a loop. The original code had a classic Python "late binding closure" issue where the `_callback` function captured `callback_id` by reference rather than by value. When a request contained multiple callback arguments, all generated callback functions would reference the same variable, and by the time any callback was invoked, `callback_id` would hold the value from the last iteration of the loop.

**Options Considered**:

1. Use a factory function to create closures with proper binding
2. Use `functools.partial` to bind the callback_id
3. Use default parameter binding (`_callback_id: str = callback_id`) - **Chosen**

**Final Decision & Rationale**:
Selected option 3 (default parameter binding) because:

- It's the most Pythonic and idiomatic solution
- Minimal code change - only adds a default parameter
- No additional imports or helper functions needed
- Default arguments are evaluated at function definition time, capturing the correct value
- Clear and maintainable for future developers

**Key Changes Made**:

- Modified `interop/python/kkrpc/server.py`, lines 63-73
- Changed `def _callback(*callback_args: Any) -> None:` to `def _callback(*callback_args: Any, _callback_id: str = callback_id) -> None:`
- Updated the method reference from `callback_id` to `_callback_id` inside the function body
- This ensures each callback closure captures its own copy of the callback ID at definition time

**Impact**:

- Fixes a real bug that would cause incorrect callback routing when multiple callbacks are passed in a single RPC call
- The bug was discovered during code review and confirmed to exist in the codebase
- No breaking changes to the API

## 11:32 - Fixed Rust WebSocket Transport Hang on Connection Close

**Core Decision/Topic**: Fixed a critical bug in the Rust WebSocket transport where `read()` would block forever when the connection closes before any message arrives.

**Problem Analysis**:
The `WebSocketTransport` uses a background thread to read messages from the WebSocket and a `Condvar` to notify the main thread. When the WebSocket connection closes (or errors), the reader thread simply exits with `break`, but `read()` remains blocked on `cvar.wait()` waiting for a non-empty queue. This causes `Client::call()` to hang indefinitely if the server closes the connection before responding.

**Options Considered**:

1. Add a separate `closed` flag and check it in `read()` - requires additional synchronization
2. Use `cvar.notify_all()` on close and check a flag - more complex, race-prone
3. Push a sentinel value (`None`) to the queue on close - **Chosen**

**Final Decision & Rationale**:
Selected option 3 (sentinel value) because:

- Simple and elegant solution using Rust's type system
- Changes queue type from `VecDeque<String>` to `VecDeque<Option<String>>`
- `None` acts as a sentinel indicating connection closed
- `read()` uses `.flatten()` to convert `Option<Option<String>>` to `Option<String>`
- No additional flags or complex synchronization needed
- Follows Rust idioms for signaling end-of-stream

**Key Changes Made**:

- Modified `interop/rust/src/lib.rs`:
  - Changed `queue` type from `VecDeque<String>` to `VecDeque<Option<String>>`
  - WebSocket reader thread pushes `Some(text)` for messages, `None` on close/error
  - `read()` method uses `queue.pop_front().flatten()` to handle sentinel

**Impact**:

- Fixes a real bug that would cause `Client::call()` to hang forever on connection close
- Proper error propagation: `read()` returns `None`, client receiver gets channel closed error
- No breaking changes to the public API

**Future Considerations**:

- Consider adding a test case that tests connection close behavior
- Review other transports (stdio) for similar issues with EOF handling
- Document this pattern for future transport implementations

---

**Previous Entry - 11:25 - Python RPC Server Callback Closure Bug**

(See above for details on the Python callback closure fix)

**Combined Future Considerations**:

- Add test cases for both issues: multiple callbacks in Python, connection close in Rust
- Review Go implementation for similar closure and connection handling issues
- Document common pitfalls in interop implementations
- Consider adding integration tests that simulate connection failures
