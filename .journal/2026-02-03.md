# 2026-02-03

## 21:50 - Fixed pkg Binary Build Error in Tauri Demo

**Core Issue**: The Node.js sidecar binary was failing at runtime with `Error: UNEXPECTED-20` when built with `pkg`. The error occurred because `pkg` couldn't properly handle ESM format with `import.meta.url` and dynamic chunk loading.

### Error Details

```
Error: UNEXPECTED-20
    at readFileFromSnapshot (pkg/prelude/bootstrap.js:1070:16)
    at Object.readFileSync (pkg/prelude/bootstrap.js:1094:18)
```

### Root Causes Identified

1. **ESM `import.meta.url` incompatibility**: The bundled code contained `import.meta.url` which pkg has trouble snapshotting
2. **Code splitting creating multiple chunks**: `Bun.build()` with `splitting: true` created separate chunk files that weren't included in the pkg snapshot
3. **External file import**: `node.ts` imported `package.json` from outside the project using `with { type: "json" }` syntax

### Options Considered

1. **Use `--assets` flag with pkg**: Tried including external files in the snapshot, but didn't work with `import.meta.url`
2. **Copy package.json into build directory**: Would require modifying the import path in source code
3. **Build as CommonJS (CJS) format**: Eliminates `import.meta.url` and produces a single file bundle
4. **Upgrade to latest pkg (6.12.0)**: Network issues prevented downloading prebuilt Node.js binaries, causing compilation from source (very slow)

### Final Decision & Rationale

**Chosen approach**: Build as CommonJS format using `bun build --format=cjs`

**Why**:

- CJS format eliminates `import.meta.url` entirely
- Single-file output (no code splitting needed)
- Works reliably with pkg 6.3.2 (stable version)
- Minimal code changes required
- Fast build times (no Node.js compilation from source)

### Key Changes Made

**File: `examples/tauri-demo/build.ts`**

- Changed from `Bun.build({ splitting: true })` to `bun build --format=cjs --target=node`
- This produces a single CommonJS file without `import.meta.url`

**File: `examples/tauri-demo/src/backend/node.ts`**

- Removed problematic `package.json` import: `import pkg from "..." with { type: "json" }`
- Removed `--version` flag handling (non-essential feature)
- Binary now starts without external file dependencies

**File: `examples/tauri-demo/package.json`**

- Pinned `@yao-pkg/pkg` to exact version `6.3.2` (removed `^`)
- Latest 6.12.0 has network/cache issues causing slow Node.js compilation from source

### Verification

Binary now runs successfully:

```bash
./src-tauri/binaries/node-aarch64-apple-darwin
# Output: Node process starts
#         Server is running
```

### Future Considerations

1. **Version flag**: Could re-add `--version` support by hardcoding version or using build-time environment variable
2. **pkg upgrade**: Monitor @yao-pkg/pkg releases for network/cache fix; upgrade when stable
3. **ESM support**: If pkg improves ESM support in future, could revert to ESM format for better tree-shaking

### Files Modified

- `examples/tauri-demo/build.ts`
- `examples/tauri-demo/src/backend/node.ts`
- `examples/tauri-demo/package.json`

---

## 21:55 - Fixed Bun eval() ES Module Support in Tauri Demo

**Core Issue**: Bun's sidecar was failing to execute code containing ES module `import` statements, showing error:

```
Unexpected token '{'. import call expects one or two arguments.
```

This occurred because Bun's `eval()` runs in **script mode**, not **module mode**, so it doesn't support ES module syntax like `import` statements.

### Root Cause

When the frontend sent code like:

```javascript
import { Database } from "bun:sqlite"

console.log("hello")
```

The `api.eval()` method used `eval(code)`, which in Bun's context is script-mode only and doesn't support ES modules.

### Investigation Path

1. **First attempt**: Use `import()` with `data:text/javascript;charset=utf-8,${encodeURIComponent(code)}`
   - Result: Bun doesn't execute the code (returns module with encoded string as default export)
2. **Second attempt**: Use `import()` with base64 encoding: `data:text/javascript;base64,${base64}`
   - Result: âœ… Works! Bun executes the code and returns the actual module exports

### Final Solution

Changed `api.ts` to use dynamic `import()` with base64-encoded data URL:

**Before:**

```typescript
export class Api {
	eval(code: string) {
		return eval(code) // Only works with Node/Deno, not Bun
	}
}
```

**After:**

```typescript
export class Api {
	async eval(code: string) {
		const base64 = Buffer.from(code).toString("base64")
		const dataUrl = `data:text/javascript;base64,${base64}`
		return await import(dataUrl) // Works with all runtimes
	}
}
```

### Why Base64 Encoding Works

Bun's `import()` handles data URLs differently based on encoding:

- **encodeURIComponent**: Returns module with raw encoded string (doesn't execute)
- **base64**: Properly decodes and executes the JavaScript code

### Key Changes Made

**File: `examples/tauri-demo/src/backend/api.ts`**

- Changed from `eval(code)` to `await import(dataUrl)` with base64 encoding
- Made method `async` to handle the dynamic import Promise
- All three runtimes (Node, Deno, Bun) now use the same implementation

### Verification

Bun binary now executes code with ES module imports:

```bash
echo 'import { Database } from "bun:sqlite"; console.log("SQLite works!");' | ./bun-binary
# Output: SQLite works!
```

### Future Considerations

1. **Performance**: Base64 encoding adds ~33% overhead to code size; acceptable for demo purposes
2. **Error handling**: Could add try/catch around the import for better error messages
3. **Security**: Data URL imports have same-origin restrictions; generally safe for this use case

### Files Modified

- `examples/tauri-demo/src/backend/api.ts`
