# RabbitMQ Adapter Implementation - 2025-11-04

## Core Decision/Topic
Implemented a complete RabbitMQ adapter for the kkrpc library to enable message queue-based RPC communication.

## Options Considered
1. **Direct Queue Approach**: Each adapter would create its own queue and publish directly to other queues
2. **Topic Exchange Approach**: Use a shared topic exchange with routing keys for message distribution
3. **Fanout Exchange Approach**: Broadcast all messages to all queues

## Final Decision & Rationale
Chose the **Topic Exchange Approach** because:
- Provides better scalability and flexibility for future features
- Allows multiple consumers to receive the same messages
- Supports routing key patterns for more sophisticated message routing
- Standard RabbitMQ pattern for pub/sub messaging
- Enables easy separation of kkrpc traffic from other queue consumers

## Key Changes Made

### New Files Created
- `packages/kkrpc/src/adapters/rabbitmq.ts` - Complete RabbitMQ adapter implementation (217 lines)
- `packages/kkrpc/test-rabbitmq-manual.ts` - Manual test script for development and debugging
- `packages/kkrpc/rabbitmq.ts` - Public export file for the RabbitMQ adapter

### Core Implementation Details
- **RabbitMQIO Class**: Full implementation of the IoInterface protocol
- **Connection Management**: Async connection with proper error handling and cleanup
- **Message Routing**: Uses topic exchange with configurable routing keys (`kkrpc.messages` default)
- **Session Management**: Unique session IDs for each adapter instance (26-character random strings)
- **Queue Management**: Exclusive inbound queues with auto-delete for proper cleanup
- **Message Serialization**: String-based messaging compatible with existing RPCChannel

### Configuration Options
```typescript
interface RabbitMQOptions {
  url?: string                    // AMQP connection URL (default: amqp://localhost)
  exchange?: string              // Exchange name (default: kkrpc-exchange)
  exchangeType?: 'topic' | 'direct' | 'fanout'  // Exchange type (default: topic)
  durable?: boolean              // Queue durability (default: true)
  sessionId?: string             // Custom session ID (auto-generated if not provided)
  routingKeyPrefix?: string      // Prefix for routing keys (default: kkrpc)
}
```

### Key Features
- **Bidirectional Communication**: Full support for both client and server modes
- **Message Durability**: Configurable persistent messaging
- **Connection Recovery**: Proper error handling and connection state management
- **Cleanup Protocol**: Graceful shutdown with destroy signaling
- **Multi-consumer Support**: Multiple adapters can share the same exchange

### Package Updates
- Updated `package.json` to include `amqplib` dependency
- Added RabbitMQ adapter to main module exports in `mod.ts`
- Updated build configuration to include the new adapter

### Testing Infrastructure
- Manual test script with example API (echo, add functions)
- Proper setup/teardown sequences for testing
- Environment variable support for RabbitMQ connection URL
- Random exchange naming for isolated test environments

## Technical Challenges Addressed
1. **Async Connection Handling**: Implemented connection promise to ensure operations wait for RabbitMQ connection
2. **Message Queue Management**: Proper handling of inbound message queue with promise-based read operations
3. **Session Isolation**: Used unique queue names and session IDs to prevent cross-traffic interference
4. **Error Propagation**: Proper error handling through the RPC channel boundary
5. **Resource Cleanup**: Comprehensive cleanup protocol for queues, channels, and connections

## Future Considerations
- **Connection Pooling**: Could implement connection pooling for better resource management
- **Message Priorities**: RabbitMQ supports message priorities that could be leveraged
- **Dead Letter Queues**: Could add DLQ support for failed message handling
- **Cluster Support**: Implementation could be enhanced for RabbitMQ cluster environments
- **Monitoring**: Add metrics and monitoring hooks for production usage
- **Security**: Could add SSL/TLS support and enhanced authentication mechanisms

## Integration Notes
- The adapter follows the same IoInterface pattern as existing adapters (WebSocket, Socket.IO, etc.)
- Fully compatible with existing RPCChannel functionality
- No changes required to existing code when using RabbitMQ as transport
- Maintains the same API surface for seamless swapping of transport layers

## Core Infrastructure Changes
The RabbitMQ implementation required updates to the core RPC channel infrastructure:

### Interface Updates
- Enhanced `IoInterface` with optional `destroy()` and `signalDestroy()` methods for proper resource cleanup
- Added type guard support for detecting destroyable interfaces
- Maintained backward compatibility with existing adapters

### RPCChannel Enhancements
- Added `destroy()` method to RPCChannel for proper cleanup
- Enhanced message listening loop to detect destroyed adapters and stop processing
- Improved error handling to gracefully handle adapter destruction
- Added `freeCallbacks()` integration for memory management

### Error Handling Improvements
- Enhanced error detection for destroyed adapter states
- Improved message loop termination conditions
- Better integration with adapter lifecycle management

These changes ensure that RabbitMQ (and future adapters) can properly manage resources and provide clean shutdown capabilities, which is essential for message queue systems where connection management is critical.

## Development Workflow
- Used manual testing approach due to RabbitMQ dependency requirements
- Created isolated test environments with random exchange names
- Implemented proper cleanup sequences to prevent queue pollution
- Added comprehensive error logging for debugging

This implementation provides enterprise-grade messaging capabilities to the kkrpc library while maintaining full compatibility with the existing architecture and API design.